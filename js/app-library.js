/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_cjmia_dashboard"] = self["webpackChunk_cjmia_dashboard"] || []).push([["app-library"],{

/***/ "../../shared/library/index.js":
/*!*************************************!*\
  !*** ../../shared/library/index.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var amcharts3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! amcharts3 */ \"../../node_modules/amcharts3/amcharts/amcharts.js\");\n/* harmony import */ var amcharts3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(amcharts3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var amcharts3_amcharts_pie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! amcharts3/amcharts/pie */ \"../../node_modules/amcharts3/amcharts/pie.js\");\n/* harmony import */ var amcharts3_amcharts_pie__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(amcharts3_amcharts_pie__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var amcharts3_amcharts_radar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! amcharts3/amcharts/radar */ \"../../node_modules/amcharts3/amcharts/radar.js\");\n/* harmony import */ var amcharts3_amcharts_radar__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(amcharts3_amcharts_radar__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var amcharts3_amcharts_serial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! amcharts3/amcharts/serial */ \"../../node_modules/amcharts3/amcharts/serial.js\");\n/* harmony import */ var amcharts3_amcharts_serial__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(amcharts3_amcharts_serial__WEBPACK_IMPORTED_MODULE_3__);\n//amchart3 라이브러리\n\n\n\n\nconst files = __webpack_require__(\"../../shared/library sync recursive \\\\.js$\");\nconst modules = {};\nfiles.keys().forEach(key => {\n  if (key === './index.js') return;\n  modules[key.toLowerCase().replace(/(\\.\\/|\\.js)/g, '')] = files(key).default;\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (modules);\n\n//# sourceURL=webpack://@cjmia/dashboard/../../shared/library/index.js?");

/***/ }),

/***/ "../../shared/library/jQWCloudv3.4.1.js":
/*!**********************************************!*\
  !*** ../../shared/library/jQWCloudv3.4.1.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.array.push.js */ \"../../node_modules/core-js/modules/es.array.push.js\");\n/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ \"../../node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);\n\n\n(function ($) {\n  var LB = 1,\n    //Left Bottom\n    LT = 2,\n    //Left Top\n    RT = 3,\n    //Right Top\n    RB = 4,\n    //Right Bottom\n    HR = 1,\n    //Horizontal\n    VR = 2,\n    //Vertical\n    WordObjType = 'span',\n    DIV = 'div',\n    distance_Counter = 1,\n    word_counter = 1,\n    cloudOpts = null;\n  function Util() {}\n  //To Generate Random Colors For Words\n  Util.getRandomColor = function () {\n    var letters = '0123456789ABCDEF'.split('');\n    var color = '#';\n    for (var i = 0; i < 6; i++) {\n      color += letters[Math.round(Math.random() * 15)];\n    }\n    return color;\n  };\n  function space(spaceType, width, height, x, y) {\n    this.spaceType = spaceType;\n    this.width = width;\n    this.height = height;\n    this.x = x;\n    this.y = y;\n  }\n  function Word(wordConfig) {\n    this.code = wordConfig.code;\n    this.word = wordConfig.word;\n    this.weight = wordConfig.weight;\n    this.fontFactor = wordConfig.fontFactor;\n    this.fontOffset = wordConfig.fontOffset;\n    this.minWeight = wordConfig.minWeight;\n    this.padding_left = wordConfig.padding_left;\n    this.font_family = wordConfig.font_family;\n    this.font = null;\n    this.color = wordConfig.color;\n    this.span = null;\n    this.width = null;\n    this.height = null;\n    this.word_class = wordConfig.word_class;\n    this.legend = wordConfig.legend ? wordConfig.legend : false;\n    this._init();\n  }\n  Word.prototype = {\n    _init: function () {\n      this._setFont();\n      this._setSpan_Size();\n    },\n    _setFont: function () {\n      this.font = Math.floor((this.weight - this.minWeight) * this.fontFactor + this.fontOffset);\n    },\n    _setSpan_Size: function () {\n      var span = document.createElement(WordObjType);\n      span.setAttribute('id', 'Word_' + word_counter++ + '_' + this.weight);\n      document.body.appendChild(span);\n      $(span).css({\n        position: 'absolute',\n        display: 'block',\n        left: -999990,\n        top: 0\n      });\n      $(span).css('font-size', this.font + 'px');\n      if (this.word_class != null && this.word_class != '') $(span).addClass(this.word_class);\n      var color;\n      if (this.color != null && this.color != '') color = this.color;else color = '#666666';\n      $(span).attr('data-bubble-id', cloudOpts.id + '_' + this.code);\n      $(span).attr('data-code', this.code);\n      $(span).css('color', color);\n      $(span).css('-webkit-user-select', 'none').css('-moz-user-select', 'none').css('-ms-user-select', 'none');\n      $(span).css('user-select', 'none').css('-o-user-select', 'none');\n      $(span).css('line-height', this.font + 'px');\n      if (this.padding_left == null) this.padding_left = 0;\n      $(span).html(\"<span class='bg' style='border-color:\" + color + ';background:' + color + \"CC'></span><span>\" + this.word + '</span>');\n      this.width = $(span).outerWidth() + 6;\n      this.height = $(span).outerHeight() + 6;\n      $(span).remove();\n      this.span = span;\n    }\n  };\n  function WordCloud() {\n    this.defaultOptions = {\n      title: 'JQ WOrd Cloud',\n      words: [],\n      minFont: 10,\n      maxFont: 50,\n      fontOffset: 0,\n      showSpaceDIV: false,\n      verticalEnabled: true,\n      cloud_color: null,\n      cloud_font_family: null,\n      spaceDIVColor: 'white',\n      padding_left: null,\n      word_common_classes: null,\n      word_click: function () {},\n      word_mouseOver: function () {},\n      word_mouseEnter: function () {},\n      word_mouseOut: function () {},\n      beforeCloudRender: function () {},\n      afterCloudRender: function () {}\n    };\n    this.minWeight = null;\n    this.maxWeight = null;\n    this.spaceDataObject = null;\n    this.spaceIdArray = null;\n    this.words = null;\n    this.fontFactor = 1, this.methods = {\n      destroy: this._destroy\n    };\n  }\n  WordCloud.prototype = {\n    _init: function (options) {\n      distance_Counter = 1;\n      word_counter = 1;\n      cloudOpts = options;\n\n      //Calling Methods from this.Methods{}\n      if (options != null && typeof options === 'string') if (this.methods[options] != null) return this.methods[options].apply();else return null;\n      if (options == null) this.options = this.defaultOptions;else if (options != null && typeof options === 'object') this.options = $.extend(this.defaultOptions, options);\n      this.spaceDataObject = {};\n      this.spaceIdArray = [];\n      this.words = this.options.words;\n      //Sorting Words according weight descending order\n      this.words.sort(function (a, b) {\n        if (a.weight < b.weight) {\n          return 1;\n        } else if (a.weight > b.weight) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n      this.options.beforeCloudRender();\n      this._start();\n      this.options.afterCloudRender();\n      this._final();\n    },\n    _setFontFactor: function () {\n      this.maxWeight = this.words[0].weight;\n      this.minWeight = this.words[this.words.length - 1].weight;\n      this.fontFactor = (this.options.maxFont - this.options.minFont) / (this.maxWeight - this.minWeight);\n    },\n    _start: function () {\n      this._destroy();\n      this._setFontFactor();\n      this._draw();\n    },\n    _final: function () {},\n    _destroy: function () {\n      this.$target.html('');\n    },\n    _setTarget: function ($target) {\n      this.$target = $target;\n      $target.css('position', 'relative');\n      this.tWidth = $target.innerWidth();\n      this.xOffset = this.tWidth / 2;\n      this.tHeight = $target.innerHeight();\n      this.yOffset = this.tHeight / 2;\n    },\n    _draw: function () {\n      // for(var index=0; index<this.words.length; index++){\n      var _this = this;\n      this.words.filter(function ($item, index) {\n        var currWord = $item;\n        var wordConfigObj = {};\n        wordConfigObj['code'] = currWord.code;\n        wordConfigObj['word'] = currWord.word;\n        wordConfigObj['weight'] = currWord.weight;\n        if (_this.options.cloud_color != null) wordConfigObj['color'] = _this.options.cloud_color;else wordConfigObj['color'] = currWord.color;\n        if (_this.options.padding_left != null) wordConfigObj['padding_left'] = _this.options.padding_left;\n        wordConfigObj['word_class'] = currWord.word_class;\n        if (_this.options.cloud_font_family != null) wordConfigObj['font_family'] = _this.options.cloud_font_family;else wordConfigObj['font_family'] = currWord.font_family;\n        wordConfigObj['fontFactor'] = _this.fontFactor;\n        wordConfigObj['fontOffset'] = _this.options.fontOffset + _this.options.minFont;\n        wordConfigObj['minWeight'] = _this.minWeight;\n        var wordObj = new Word(wordConfigObj);\n        if (_this.options.word_common_classes != null) $(wordObj.span).addClass(_this.options.word_common_classes);\n        var data = JSON.parse(JSON.stringify(_this.words[index]));\n        $(wordObj.span).on('click', function () {\n          _this.options.word_click(currWord);\n        });\n        $(wordObj.span).on('mouseover', function ($e) {\n          _this.options.word_mouseOver($e, currWord);\n        });\n        $(wordObj.span).on('mouseout', function ($e) {\n          _this.options.word_mouseOut($e, currWord);\n        });\n        $(wordObj.span).on('mouseenter', _this.options.word_mouseEnter);\n        if (index == 0) _this._placeFirstWord(wordObj);else _this._placeOtherWord(wordObj);\n      });\n    },\n    _updateSpaceIdArray: function (distanceS, distance) {\n      if (this.spaceIdArray.length != 0) {\n        for (var index = 0; index < this.spaceIdArray.length; index++) {\n          if (distance < parseFloat(this.spaceIdArray[index].split('_')[0])) {\n            this.spaceIdArray.splice(index, 0, distanceS);\n            return;\n          }\n        }\n        this.spaceIdArray.push(distanceS);\n      } else this.spaceIdArray.push(distanceS);\n    },\n    _showSpaceDiv: function (type, w, h, x, y) {\n      var xMul = 1;\n      var yMul = 1;\n      switch (type) {\n        case LB:\n          xMul = 0;\n          yMul = -1;\n          break;\n        case LT:\n          xMul = 0;\n          yMul = 0;\n          break;\n        case RT:\n          xMul = -1;\n          yMul = 0;\n          break;\n        case RB:\n          xMul = -1;\n          yMul = -1;\n          break;\n      }\n      var div = document.createElement(DIV);\n      $(div).css('left', parseInt(x + xMul * w)).css('top', parseInt(y + yMul * h)).css('width', w).css('height', h).css('border', '1px ' + this.options.spaceDIVColor + ' solid').css('position', 'absolute').css('display', 'block');\n      this.$target.append(div);\n    },\n    _pushSpaceData: function (type, w, h, x, y) {\n      //Calculating Distance between (x,y): Key point of Space and and Center of Container (this.xOffset,this.yOffset)\n      var distance = Math.sqrt((this.xOffset - x) * (this.xOffset - x) + (this.yOffset - y) * (this.yOffset - y));\n      var distanceS = distance + '_' + distance_Counter++;\n\n      //Update Space Id Array\n      this._updateSpaceIdArray(distanceS, distance);\n      //Add Space into Space Data Object\n      this.spaceDataObject[distanceS] = new space(type, w, h, x, y);\n\n      // To Show The Space\n      if (this.options.showSpaceDIV) {\n        this._showSpaceDiv(type, w, h, x, y);\n      }\n    },\n    _placeFirstWord: function (word) {\n      var w = word.width;\n      var h = word.height;\n      var xoff = this.xOffset - w / 2;\n      var yoff = this.yOffset - h / 2;\n      var tw = this.tWidth;\n      var th = this.tHeight;\n      var span = word.span;\n      $(span).css('left', xoff).css('top', yoff).css('display', 'inline');\n      this.$target.append(span);\n      this._pushSpaceData(LB, tw - xoff - w, h, xoff + w, yoff + h / 2); //M1\n      this._pushSpaceData(LT, w, th - yoff - h, xoff + w / 2, yoff + h); //M2\n      this._pushSpaceData(RT, xoff, h, xoff, yoff + h / 2); //M3\n      this._pushSpaceData(RB, w, yoff, xoff + w / 2, yoff); //M4\n\n      this._pushSpaceData(LT, w / 2, h / 2, xoff + w, yoff + h / 2); //C1\n      this._pushSpaceData(RT, w / 2, h / 2, xoff + w / 2, yoff + h); //C2\n      this._pushSpaceData(RB, w / 2, h / 2, xoff, yoff + h / 2); //C3\n      this._pushSpaceData(LB, w / 2, h / 2, xoff + w / 2, yoff); //C4\n\n      this._pushSpaceData(LT, tw - xoff - w - w / 2, th - yoff - h / 2, xoff + w + w / 2, yoff + h / 2); //S1\n      this._pushSpaceData(RT, xoff + w / 2, th - yoff - h - h / 2, xoff + w / 2, yoff + h + h / 2); //S2\n      this._pushSpaceData(RB, xoff - w / 2, yoff + h / 2, xoff - w / 2, yoff + h / 2); //S3\n      this._pushSpaceData(LB, xoff + w / 2, yoff - h / 2, xoff + w / 2, yoff - h / 2); //S4\n    },\n    _placeOtherWord: function (word) {\n      for (var index = 0; index < this.spaceIdArray.length; index++) {\n        var spaceId = this.spaceIdArray[index];\n        var obj = this.spaceDataObject[spaceId];\n        var alignmentInd = 0;\n        var alignmentIndCount = 0;\n        if (word.width <= obj.width && word.height <= obj.height) {\n          alignmentInd = HR;\n          alignmentIndCount++;\n        }\n        if (this.options.verticalEnabled) {\n          if (word.height <= obj.width && word.width <= obj.height) {\n            alignmentInd = VR;\n            alignmentIndCount++;\n          }\n        }\n        if (alignmentIndCount > 0) {\n          this.spaceDataObject[spaceId] = null;\n          this.spaceIdArray.splice(index, 1);\n\n          //For Word's Span Position\n          var xMul = 1;\n          var yMul = 1;\n\n          //For new Child Spaces\n          var xMulS = 1;\n          var yMulS = 1;\n          switch (obj.spaceType) {\n            case LB:\n              xMul = 0;\n              yMul = -1;\n              xMulS = 1;\n              yMulS = -1;\n              break;\n            case LT:\n              xMul = 0;\n              yMul = 0;\n              xMulS = 1;\n              yMulS = 1;\n              break;\n            case RT:\n              xMul = -1;\n              yMul = 0;\n              xMulS = -1;\n              yMulS = 1;\n              break;\n            case RB:\n              xMul = -1;\n              yMul = -1;\n              xMulS = -1;\n              yMulS = -1;\n              break;\n          }\n          if (alignmentIndCount > 1) {\n            //Making Horizontal Word in Larger Number\n            // Random number[0,5] is >0 and <3 --> HR\n            // Random number[0,5] is >3 --> VR\n\n            if (Math.random() * 5 > 3) alignmentInd = VR;else alignmentInd = HR;\n          }\n          var w = word.width;\n          var h = word.height;\n          switch (alignmentInd) {\n            case HR:\n              var span = word.span;\n              $(span).css('left', obj.x + xMul * w).css('top', obj.y + yMul * h).css('display', 'inline');\n              this.$target.append(span);\n              if (Math.random() * 2 > 1) {\n                /*\r\n                 * \t\t\t_________________________________\r\n                 *\t\t\t|\t\t\t\t\t\t\t\t|\r\n                 *\t\t\t|\t\t\t\tT\t\t\t\t|\r\n                 *\t\t\t|\t\t\t\t\t\t\t\t|\r\n                 *\t\t\t|_______________________________|\r\n                 *\t\t\t|\t\t\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t  WORD\t\t|\t\tR\t\t|\r\n                 *\t\t\t|\t********\t|\t\t\t\t|\r\n                 *\t\t\t|_______________|_______________|\r\n                 *\r\n                 */\n\n                this._pushSpaceData(obj.spaceType, obj.width - w, h, obj.x + xMulS * w, obj.y); //R\n                this._pushSpaceData(obj.spaceType, obj.width, obj.height - h, obj.x, obj.y + yMulS * h); //T\n              } else {\n                /*\r\n                 * \t\t\t_________________________________\r\n                 *\t\t\t|\t\t\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t\tT\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t\t\t\t|\t\t\t\t|\r\n                 *\t\t\t|_______________|\t\tR\t\t|\r\n                 *\t\t\t|\t\t\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t  WORD\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t********\t|\t\t\t\t|\r\n                 *\t\t\t|_______________|_______________|\r\n                 *\r\n                 */\n\n                this._pushSpaceData(obj.spaceType, obj.width - w, obj.height, obj.x + xMulS * w, obj.y); //R\n                this._pushSpaceData(obj.spaceType, w, obj.height - h, obj.x, obj.y + yMulS * h); //T\n              }\n              break;\n            case VR:\n              var span = word.span;\n              //IE Handling for Differenet way of Rotation Transforms\n              if ((jquery__WEBPACK_IMPORTED_MODULE_1___default().browser) && (jquery__WEBPACK_IMPORTED_MODULE_1___default().browser).msie) {\n                $(span).css('left', obj.x + xMul * h).css('top', obj.y + yMul * w);\n              } else {\n                $(span).css('left', obj.x + xMul * h - (w - h) / 2).css('top', obj.y + yMul * w + (w - h) / 2);\n              }\n              $(span).css('display', 'block').css('-webkit-transform', 'rotate(270deg)').css('-moz-transform', 'rotate(270deg)');\n              $(span).css('-o-transform', 'rotate(270deg)').css('filter', 'progid:DXImageTransform.Microsoft.BasicImage(rotation=3)');\n              this.$target.append(span);\n              if (Math.random() * 2 > 1) {\n                /*\r\n                 * \t\t\t_________________________________\r\n                 *\t\t\t|\t\t\t\t\t\t\t\t|\r\n                 *\t\t\t|\t\t\t\tT\t\t\t\t|\r\n                 *\t\t\t|\t\t\t\t\t\t\t\t|\r\n                 *\t\t\t|_______________________________|\r\n                 *\t\t\t|\t\tD\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t\tR\t\t|\t\tR\t\t|\r\n                 *\t\t\t|\t\tO\t\t|\t\t\t\t|\r\n                 *\t\t\t|_______W_______|_______________|\r\n                 *\r\n                 */\n\n                this._pushSpaceData(obj.spaceType, obj.width - h, w, obj.x + xMulS * h, obj.y); //R\n                this._pushSpaceData(obj.spaceType, obj.width, obj.height - w, obj.x, obj.y + yMulS * w); //T\n              } else {\n                /*\r\n                 * \t\t\t_________________________________\r\n                 *\t\t\t|\t\t\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t\tT\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t\t\t\t|\t\t\t\t|\r\n                 *\t\t\t|_______________|\t\tR\t\t|\r\n                 *\t\t\t|\t\tD\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t  \tR\t\t|\t\t\t\t|\r\n                 *\t\t\t|\t\tO\t\t|\t\t\t\t|\r\n                 *\t\t\t|_______W_______|_______________|\r\n                 *\r\n                 */\n\n                this._pushSpaceData(obj.spaceType, obj.width - h, obj.height, obj.x + xMulS * h, obj.y); //R\n                this._pushSpaceData(obj.spaceType, h, obj.height - w, obj.x, obj.y + yMulS * w); //T\n              }\n              break;\n          }\n          return;\n        }\n      }\n    }\n  };\n  $.fn.jQWCloud = function (options) {\n    var wc = new WordCloud();\n    wc._setTarget($(this));\n    $.data(this, 'jqw_cloud', wc);\n    wc._init(options);\n  };\n})((jquery__WEBPACK_IMPORTED_MODULE_1___default()));\n\n//# sourceURL=webpack://@cjmia/dashboard/../../shared/library/jQWCloudv3.4.1.js?");

/***/ }),

/***/ "../../shared/library/jquery-treemap.js":
/*!**********************************************!*\
  !*** ../../shared/library/jquery-treemap.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"../../node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);\n\n(function ($) {\n  var clickChk = false;\n  function Rectangle(x, y, width, height, margin) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.margin = margin;\n  }\n  Rectangle.prototype.style = function () {\n    return {\n      top: this.y + 'px',\n      left: this.x + 'px',\n      width: this.width - this.margin + 'px',\n      height: this.height - this.margin + 'px'\n    };\n  };\n  Rectangle.prototype.isWide = function () {\n    return this.width > this.height;\n  };\n  function TreeMap($div, options) {\n    if (options.click != undefined) clickChk = true;\n    options = options || {};\n    this.$div = $div;\n    $div.css('position', 'relative');\n    this.rectangle = new Rectangle(0, 0, $div.width(), $div.height(), 0);\n    this.nodeClass = function () {\n      return '';\n    };\n    this.click = function () {};\n    this.mouseenter = function () {};\n    this.mouseleave = function () {};\n    this.mousemove = function () {};\n    this.paintCallback = function () {};\n    this.ready = function () {};\n    this.itemMargin = 0;\n    this.smallestFontSize = 15;\n    this.startingFontSize = 24;\n    this.centerLabelVertically = true;\n    $.extend(this, options);\n    this.setNodeColors = function ($box, node) {\n      if (this.backgroundColor) $box.css('background-color', this.backgroundColor($box, node));\n      if (this.color) $box.css('color', this.color($box, node));\n    };\n  }\n  TreeMap.SIDE_MARGIN = 20;\n  TreeMap.TOP_MARGIN = 20;\n  TreeMap.prototype.paint = function (nodeList) {\n    nodeList = this.squarify(nodeList, this.rectangle);\n    if (this.$div.children().length > 0) this.$div.html('');\n    for (var i = 0; i < nodeList.length; i++) {\n      var node = nodeList[i];\n      var nodeBounds = node.bounds;\n      var boxId = node.id || 'treemap-node-' + i;\n      var $box = $('<div id=' + boxId + '></div>');\n      $box.css($.extend(nodeBounds.style(), {\n        position: 'absolute',\n        'text-align': 'center'\n      }));\n      this.setNodeColors($box, node);\n      $box.addClass('treemap-node');\n      var overlay = $(\"<div class='overlay'></div>\");\n      if (clickChk) overlay = $(\"<a href='#' class='overlay'></a>\");\n      var self = this;\n      overlay.bind('click', node, function (e) {\n        self.click(e.data, e);\n        return false;\n      });\n      overlay.bind('mouseenter', node, function (e) {\n        self.mouseenter(e.data, e);\n      });\n      overlay.bind('mouseleave', node, function (e) {\n        self.mouseleave(e.data, e);\n      });\n      overlay.bind('mousemove', node, function (e) {\n        self.mousemove(e.data, e);\n      });\n      $box.appendTo(this.$div);\n      $box.addClass(this.nodeClass(node, $box, nodeList.length));\n\n      // 내부 컨텐츠\n      var $content = $('<div>' + node.label + '</div>');\n      $content.addClass('treemap-item');\n      $box.append(overlay);\n      $box.append($content);\n\n      //this.fitLabelFontSize($content, node);\n\n      if (this.centerLabelVertically) {\n        $content.css('margin-top', parseInt($box.height()) / 2 - parseInt($content.height()) / 2 + 'px');\n      }\n      // 내부 컨텐츠\n    }\n    this.ready();\n  };\n  TreeMap.prototype.fitLabelFontSize = function ($content, node) {\n    var nodeBounds = node.bounds;\n    while ($content.height() + TreeMap.TOP_MARGIN > nodeBounds.height || $content.width() + TreeMap.SIDE_MARGIN > nodeBounds.width) {\n      var fontSize = parseFloat($content.css('font-size')) - 3;\n      if (fontSize < this.smallestFontSize) {\n        $content.remove();\n        break;\n      }\n      $content.css('font-size', fontSize + 'px');\n    }\n    $content.css('display', 'block');\n    this.paintCallback($content, node);\n  };\n  TreeMap.HORIZONTAL = 1;\n  TreeMap.VERTICAL = 2;\n  TreeMap.prototype.squarify = function (nodeList, rectangle) {\n    nodeList.sort(function (a, b) {\n      return b.value - a.value;\n    });\n    this.divideDisplayArea(nodeList, rectangle);\n    return nodeList;\n  };\n  TreeMap.prototype.divideDisplayArea = function (nodeList, destRectangle) {\n    // Check for boundary conditions\n    if (nodeList.length === 0) return;\n    if (nodeList.length == 1) {\n      nodeList[0].bounds = destRectangle;\n      return;\n    }\n    var halves = this.splitFairly(nodeList);\n    var leftSum = this.sumValues(halves.left),\n      rightSum = this.sumValues(halves.right),\n      totalSum = leftSum + rightSum;\n    if (destRectangle.isWide()) {\n      var midPoint = Math.round(leftSum * destRectangle.width / totalSum);\n      this.divideDisplayArea(halves.left, new Rectangle(destRectangle.x, destRectangle.y, midPoint, destRectangle.height, this.itemMargin));\n      this.divideDisplayArea(halves.right, new Rectangle(destRectangle.x + midPoint, destRectangle.y, destRectangle.width - midPoint, destRectangle.height, this.itemMargin));\n    } else {\n      var midPoint = Math.round(leftSum * destRectangle.height / totalSum);\n      this.divideDisplayArea(halves.left, new Rectangle(destRectangle.x, destRectangle.y, destRectangle.width, midPoint, this.itemMargin));\n      this.divideDisplayArea(halves.right, new Rectangle(destRectangle.x, destRectangle.y + midPoint, destRectangle.width, destRectangle.height - midPoint, this.itemMargin));\n    }\n  };\n  TreeMap.prototype.splitFairly = function (nodeList) {\n    var halfValue = this.sumValues(nodeList) / 2;\n    var accValue = 0;\n    var length = nodeList.length;\n    for (var midPoint = 0; midPoint < length; midPoint++) {\n      if (midPoint > 0 && accValue + nodeList[midPoint].value > halfValue) break;\n      accValue += nodeList[midPoint].value;\n    }\n    return {\n      left: nodeList.slice(0, midPoint),\n      right: nodeList.slice(midPoint)\n    };\n  };\n  TreeMap.prototype.sumValues = function (nodeList) {\n    var result = 0;\n    var length = nodeList.length;\n    for (var i = 0; i < length; i++) {\n      result += nodeList[i].value;\n    }\n    return result;\n  };\n  $.fn.treemap = function (json, options) {\n    var self = this;\n    return this.fadeOut(0, function () {\n      self.empty().fadeIn(0, function () {\n        new TreeMap(self, options).paint(json);\n      });\n    });\n  };\n})((jquery__WEBPACK_IMPORTED_MODULE_0___default()));\n\n//# sourceURL=webpack://@cjmia/dashboard/../../shared/library/jquery-treemap.js?");

/***/ }),

/***/ "../../shared/library/quill.js":
/*!*************************************!*\
  !*** ../../shared/library/quill.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue_quill_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-quill-editor */ \"../../node_modules/vue-quill-editor/index.js\");\n/* harmony import */ var vue_quill_editor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue_quill_editor__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var quill_html_edit_button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! quill-html-edit-button */ \"../../node_modules/quill-html-edit-button/dist/quill.htmlEditButton.min.js\");\n/* harmony import */ var quill_html_edit_button__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(quill_html_edit_button__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvue_quill_editor__WEBPACK_IMPORTED_MODULE_0__.Quill.register('modules/htmlEditButton', (quill_html_edit_button__WEBPACK_IMPORTED_MODULE_1___default()));\n\n//# sourceURL=webpack://@cjmia/dashboard/../../shared/library/quill.js?");

/***/ }),

/***/ "../../shared/library/selectable.js":
/*!******************************************!*\
  !*** ../../shared/library/selectable.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.array.push.js */ \"../../node_modules/core-js/modules/es.array.push.js\");\n/*!\r\n *\r\n * Selectable\r\n * Copyright (c) 2017 Karl Saunders (Mobius1)\r\n * Licensed under MIT (http://www.opensource.org/licenses/mit-license.php)\r\n *\r\n * Version: 0.22.0\r\n *\r\n */\n(function (root, factory) {\n  var plugin = 'Selectable';\n  if (true) {\n    module.exports = factory(plugin);\n  } else {}\n})(typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : this.window || this.global, function () {\n  'use strict';\n\n  /**\r\n   * Detect CTRL or META key press\r\n   * @param  {Object}  e Event interface\r\n   * @return {Boolean}\r\n   */\n  var _isCmdKey = function (e) {\n    return !!e.ctrlKey || !!e.metaKey;\n  };\n\n  /**\r\n   * Detect SHIFT key press\r\n   * @param  {Object}  e Event interface\r\n   * @return {Boolean}\r\n   */\n  var _isShiftKey = function (e) {\n    return !!e.shiftKey;\n  };\n  var _axes = ['x', 'y'];\n  var _axes1 = {\n    x: 'x1',\n    y: 'y1'\n  };\n  var _axes2 = {\n    x: 'x2',\n    y: 'y2'\n  };\n\n  /* SELECTABLE */\n  var Selectable = function (options) {\n    this.version = '0.22.0';\n    this.v = this.version.split('.').map(function (s) {\n      return parseInt(s, 10);\n    });\n    this.touch = 'ontouchstart' in window || window.DocumentTouch && document instanceof DocumentTouch;\n    this.init(options);\n  };\n  Selectable.prototype = {\n    /* ---------- PUBLIC METHODS ---------- */\n\n    /**\r\n     * Init instance\r\n     * @return {void}\r\n     */\n    init: function (options) {\n      if (this.initialised) return;\n\n      /**\r\n       * Default configuration properties\r\n       * @type {Object}\r\n       */\n      var selectableConfig = {\n        filter: '.ui-selectable',\n        tolerance: 'touch',\n        container: document.body,\n        touch: true,\n        toggleTouch: true,\n        toggle: false,\n        autoRefresh: true,\n        throttle: 50,\n        lassoSelect: 'normal',\n        autoScroll: {\n          threshold: 0,\n          increment: 10\n        },\n        saveState: false,\n        ignore: false,\n        maxSelectable: false,\n        lasso: {\n          border: '1px dotted #000',\n          backgroundColor: 'rgba(52, 152, 219, 0.2)'\n        },\n        keys: ['shiftKey', 'ctrlKey', 'metaKey', ''],\n        classes: {\n          lasso: 'ui-lasso',\n          handle: 'ui-handle',\n          selected: 'ui-selected',\n          container: 'ui-container',\n          selecting: 'ui-selecting',\n          selectable: 'ui-selectable',\n          deselecting: 'ui-deselecting'\n        }\n      };\n      this.config = _merge(selectableConfig, options);\n      this.origin = {\n        x: 0,\n        y: 0\n      };\n      this.mouse = {\n        x: 0,\n        y: 0\n      };\n      var o = this.config;\n\n      // Is auto-scroll enabled?\n      this.autoscroll = isObject(o.autoScroll);\n      this.lasso = false;\n      if (o.lasso && isObject(o.lasso)) {\n        this.lasso = document.createElement('div');\n        this.lasso.className = o.classes.lasso;\n        _css(this.lasso, _merge({\n          position: 'absolute',\n          boxSizing: 'border-box',\n          opacity: 0 // border will show even at zero width / height\n        }, o.lasso));\n      }\n      if (this.touch) {\n        o.toggle = o.toggleTouch;\n      }\n      if (!o.touch) {\n        this.touch = false;\n      }\n      this.callbacks = {};\n\n      // bind events\n      var events = ['_start', '_touchstart', '_drag', '_end', '_keyup', '_keydown', '_blur', '_focus'];\n      for (var i = 0, count = events.length; i < count; i++) {\n        var event = events[i];\n        this.callbacks[event] = this[event].bind(this);\n      }\n      this.callbacks._refresh = _throttle(this.refresh, o.throttle, this);\n      if (this.autoscroll) {\n        this.callbacks._scroll = this._onScroll.bind(this);\n      }\n      this.setContainer();\n      this.scroll = {\n        x: this.bodyContainer ? window.pageXOffset : this.container.scrollLeft,\n        y: this.bodyContainer ? window.pageYOffset : this.container.scrollTop\n      };\n      if (isCollection(o.filter)) {\n        this.nodes = [].slice.call(o.filter);\n      } else if (typeof o.filter === 'string') {\n        this.nodes = [].slice.call(this.container.querySelectorAll(o.filter));\n      }\n      this.hasHandle = o.handle !== false && typeof o.handle === 'string';\n\n      // activate items\n      for (var i = 0, count = this.nodes.length; i < count; i++) {\n        var node = this.nodes[i];\n        node.classList.add(o.classes.selectable);\n        if (this.hasHandle) {\n          var handles = node.querySelectorAll(o.handle);\n          if (handles.length) {\n            for (var j = 0, len = handles.length; j < len; j++) {\n              var handle = handles[j];\n              handle.classList.add(o.classes.handle);\n            }\n          }\n        }\n      }\n      this.update();\n      this.enable();\n      var that = this;\n      setTimeout(function () {\n        if (o.saveState) {\n          that.state('save');\n        }\n        that.emit('init');\n        that.initialised = true;\n      }, 10);\n    },\n    /**\r\n     * Update instance\r\n     * @return {Void}\r\n     */\n    update: function () {\n      this._loadItems();\n      this.refresh();\n      this.emit('update', this.items);\n    },\n    /**\r\n     * Update item coords\r\n     * @return {Void}\r\n     */\n    refresh: function () {\n      var ww = window.innerWidth;\n      var wh = window.innerHeight;\n      var x = this.bodyContainer ? window.pageXOffset : this.container.scrollLeft;\n      var y = this.bodyContainer ? window.pageYOffset : this.container.scrollTop;\n      this.offsetWidth = this.container.offsetWidth;\n      this.offsetHeight = this.container.offsetHeight;\n      this.clientWidth = this.container.clientWidth;\n      this.clientHeight = this.container.clientHeight;\n      this.scrollWidth = this.container.scrollWidth;\n      this.scrollHeight = this.container.scrollHeight;\n\n      // get the parent container DOMRect\n      this.boundingRect = _getElementBoundingRect(this.container);\n      if (this.bodyContainer) {\n        this.boundingRect.x2 = ww;\n        this.boundingRect.y2 = wh;\n      }\n\n      // get the parent container scroll dimensions\n      this.scroll = {\n        x: x,\n        y: y,\n        max: {\n          x: this.scrollWidth - (this.bodyContainer ? ww : this.clientWidth),\n          y: this.scrollHeight - (this.bodyContainer ? wh : this.clientHeight)\n        },\n        size: {\n          x: this.clientWidth,\n          y: this.clientHeight\n        },\n        scrollable: {\n          x: this.scrollWidth > this.offsetWidth,\n          y: this.scrollHeight > this.offsetHeight\n        }\n      };\n      for (var i = 0; i < this.nodes.length; i++) {\n        this.items[i].rect = _getElementBoundingRect(this.nodes[i]);\n      }\n      this.emit('refresh');\n    },\n    /**\r\n     * Add instance event listeners\r\n     * @return {Void}\r\n     */\n    attachEvents: function () {\n      var e = this.callbacks;\n      this.detachEvents();\n      if (this.touch) {\n        this.on(this.container, 'touchstart', e._touchstart);\n        this.on(document, 'touchend', e._end);\n        this.on(document, 'touchcancel', e._end);\n        if (this.lasso !== false) {\n          this.on(document, 'touchmove', e._drag);\n        }\n      } else {\n        this.on(this.container, 'mousedown', e._start);\n        this.on(document, 'mouseup', e._end);\n        this.on(document, 'keydown', e._keydown);\n        this.on(document, 'keyup', e._keyup);\n        this.on(this.container, 'mouseenter', e._focus);\n        this.on(this.container, 'mouseover', e._focus);\n        this.on(this.container, 'mouseleave', e._blur);\n        if (this.lasso !== false) {\n          this.on(document, 'mousemove', e._drag);\n        }\n      }\n      if (this.autoscroll) {\n        this.on(this.bodyContainer ? window : this.container, 'scroll', e._scroll);\n      }\n      this.on(window, 'resize', e._refresh);\n      this.on(window, 'scroll', e._refresh);\n    },\n    /**\r\n     * Remove instance event listeners\r\n     * @return {Void}\r\n     */\n    detachEvents: function () {\n      var e = this.callbacks;\n      this.off(this.container, 'mousedown', e._start);\n      this.off(document, 'mousemove', e._drag);\n      this.off(document, 'mouseup', e._end);\n      this.off(document, 'keydown', e._keydown);\n      this.off(document, 'keyup', e._keyup);\n      this.off(this.container, 'mouseenter', e._focus);\n      this.off(this.container, 'mouseover', e._focus);\n      this.off(this.container, 'mouseleave', e._blur);\n      if (this.autoscroll) {\n        this.off(this.bodyContainer ? window : this.container, 'scroll', e._scroll);\n      }\n\n      // Mobile\n      this.off(this.container, 'touchstart', e._touchstart);\n      this.off(document, 'touchend', e._end);\n      this.off(document, 'touchcancel', e._end);\n      this.off(document, 'touchmove', e._drag);\n      this.off(window, 'resize', e._refresh);\n      this.off(window, 'scroll', e._refresh);\n    },\n    /**\r\n     * Legacy alias of attachEvents\r\n     * @return {Void}\r\n     */\n    bind: function () {\n      this.attachEvents();\n    },\n    /**\r\n     * Legacy alias of detachEvents\r\n     * @return {Void}\r\n     */\n    unbind: function () {\n      this.detachEvents();\n    },\n    /**\r\n     * Set the container\r\n     * @param {String|Object} container CSS3 selector string or HTMLElement\r\n     */\n    setContainer: function (container) {\n      var o = this.config,\n        old;\n      if (this.container) {\n        old = this.container;\n        this.detachEvents();\n      }\n      if (container === undefined) {\n        if (o.appendTo) {\n          container = o.appendTo;\n          o.container = o.appendTo;\n        } else if (o.container) {\n          container = o.container;\n        }\n      }\n      if (typeof container === 'string') {\n        this.container = document.querySelector(container);\n      } else if (container instanceof Element && container.nodeName) {\n        this.container = container;\n      }\n      this.container.classList.add(o.classes.container);\n      this.container._selectable = this;\n      if (old) {\n        old.classList.remove(o.classes.container);\n        delete old._selectable;\n      }\n      this.bodyContainer = this.container === document.body;\n      this._loadItems();\n      if (this.autoscroll) {\n        var style = _css(this.container);\n        if (style.position === 'static' && !this.bodyContainer) {\n          this.container.style.position = 'relative';\n        }\n      }\n      this.attachEvents();\n    },\n    /**\r\n     * Select an item\r\n     * @param  {Object} item\r\n     * @return {Boolean}\r\n     */\n    select: function (item, all, save) {\n      var all = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var save = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      if (isCollection(item)) {\n        var count = this.getSelectedItems().length;\n        for (var i = 0; i < item.length; i++) {\n          if (!!this.config.maxSelectable && count >= this.config.maxSelectable) {\n            break;\n          }\n          this.select(item[i], false, false);\n          count++;\n        }\n        if (save && this.config.saveState) {\n          this.state('save');\n        }\n        return this.getSelectedItems();\n      }\n      item = this.get(item);\n      if (item) {\n        // toggle item if already selected\n        if (this.config.toggle && this.config.toggle === 'drag' && !all && item.selected && !this.cmdDown) {\n          return this.deselect(item, false);\n        }\n        var el = item.node,\n          o = this.config.classes;\n        el.classList.remove(o.selecting);\n        el.classList.add(o.selected);\n        item.selecting = false;\n        item.selected = true;\n        item.startselected = true;\n        if (save && this.config.saveState) {\n          this.state('save');\n        }\n        this.emit('select', item);\n        return item;\n      }\n      return false;\n    },\n    /**\r\n     * Unselect an item\r\n     * @param  {Object} item\r\n     * @return {Boolean}\r\n     */\n    deselect: function (item, save) {\n      if (isCollection(item)) {\n        for (var i = 0; i < item.length; i++) {\n          this.deselect(item[i], false);\n        }\n        if (save && this.config.saveState) {\n          this.state('save');\n        }\n        return this.getSelectedItems();\n      }\n      item = this.get(item);\n      if (item) {\n        var el = item.node,\n          o = this.config.classes;\n        item.selecting = false;\n        item.selected = false;\n        item.deselecting = false;\n        item.startselected = false;\n        el.classList.remove(o.deselecting);\n        el.classList.remove(o.selecting);\n        el.classList.remove(o.selected);\n        if (save && this.config.saveState) {\n          this.state('save');\n        }\n        this.emit('deselect', item);\n        return item;\n      }\n      return false;\n    },\n    /**\r\n     * Toggle an item\r\n     * @param  {Object} item\r\n     * @param  {Boolean} bool\r\n     * @return {Boolean}\r\n     */\n    toggle: function (choice, bool) {\n      if (choice === undefined) {\n        return this.invert();\n      }\n      var data = this.get(choice);\n      if (data) {\n        if (!this._isCollection(data)) {\n          data = [data];\n        }\n        for (var i = 0, len = data.length; i < len; i++) {\n          var item = data[i];\n          if (bool !== undefined) {\n            if (bool) {\n              this.select(item, false, false);\n            } else {\n              this.deselect(item, false);\n            }\n          } else {\n            if (item.selected) {\n              this.deselect(item, false);\n            } else {\n              this.select(item, false, false);\n            }\n          }\n        }\n        if (this.config.saveState) {\n          this.state('save');\n        }\n      }\n    },\n    /**\r\n     * Add a node to the instance\r\n     * @param {Object} node HTMLElement\r\n     * * @return {Void}\r\n     */\n    add: function (node) {\n      var els = [];\n      if (typeof node === 'string') {\n        node = [].slice.call(this.container.querySelectorAll(node));\n      }\n      if (!isCollection(node)) {\n        node = [node];\n      }\n      for (var i = 0, len = node.length; i < len; i++) {\n        var el = node[i];\n        if (this.nodes.indexOf(el) < 0 && el instanceof Element) {\n          els.push(el);\n          el.classList.add(this.config.classes.selectable);\n          if (this.hasHandle) {\n            var handles = el.querySelectorAll(this.config.handle);\n            if (handles.length > 0) {\n              for (var j = 0, count = handles.length; j < count; j++) {\n                var handle = handles[j];\n                handle.classList.add(this.config.classes.handle);\n              }\n            }\n          }\n        }\n      }\n      this.nodes = this.nodes.concat(els);\n      this.update();\n\n      // emit \"add\" for each new item\n      for (var i = 0; i < els.length; i++) {\n        this.emit('add', this.get(els[i]));\n      }\n    },\n    /**\r\n     * Remove an item from the instance so it's deselectable\r\n     * @param  {Mixed} item index, node or object\r\n     * @return {Boolean}\r\n     */\n    remove: function (item, stop) {\n      item = this.get(item);\n      if (item) {\n        if (isCollection(item)) {\n          for (var i = item.length - 1; i >= 0; i--) {\n            this.remove(item[i], i > 0);\n          }\n        } else {\n          var el = item.node,\n            o = this.config.classes;\n          el.classList.remove(o.selectable);\n          el.classList.remove(o.deselecting);\n          el.classList.remove(o.selecting);\n          el.classList.remove(o.selected);\n          if (this.hasHandle) {\n            const handles = el.querySelectorAll(this.config.handle);\n            if (handles.length) {\n              for (var i = 0, count = handles.length; i < count; i++) {\n                var handle = handles[i];\n                handle.classList.remove(o.handle);\n              }\n            }\n          }\n          this.nodes.splice(this.nodes.indexOf(item.node), 1);\n\n          // emit \"remove\"\n          this.emit('remove', item);\n        }\n        if (!stop) {\n          this.update();\n        }\n        return true;\n      }\n      return false;\n    },\n    /**\r\n     * Select all items\r\n     * @return {Void}\r\n     */\n    selectAll: function () {\n      var max = this.items.length;\n      if (!!this.config.maxSelectable && this.config.maxSelectable < max) {\n        max = this.config.maxSelectable;\n      }\n      for (var i = 0; i < max; i++) {\n        this.select(this.items[i], true, false);\n      }\n      if (this.config.saveState) {\n        this.state('save');\n      }\n    },\n    /**\r\n     * Invert item states\r\n     * @return {Void}\r\n     */\n    invert: function () {\n      var items = this.getItems();\n      if (!!this.config.maxSelectable && this.config.maxSelectable < items.length) {\n        return this._maxReached();\n      }\n      for (var i = 0; i < this.items.length; i++) {\n        var item = this.items[i];\n        if (item.selected) {\n          this.deselect(item, false);\n        } else {\n          this.select(item, false, false);\n        }\n      }\n      if (this.config.saveState) {\n        this.state('save');\n      }\n    },\n    /**\r\n     * Deselect all items\r\n     * @return {Void}\r\n     */\n    clear: function (save) {\n      var save = arguments.length > 0 && arguments[0] !== undefined ? false : true;\n      for (var i = this.items.length - 1; i >= 0; i--) {\n        this.deselect(this.items[i], false);\n      }\n      if (save && this.config.saveState) {\n        this.state('save');\n      }\n    },\n    /**\r\n     * Get an item\r\n     * @return {Object|Boolean}\r\n     */\n    get: function (item) {\n      var found = false;\n      if (typeof item === 'string') {\n        item = [].slice.call(this.container.querySelectorAll(item));\n      }\n      if (isCollection(item)) {\n        found = [];\n        for (var i = 0; i < item.length; i++) {\n          var itm = this.get(item[i]);\n          if (itm) {\n            found.push(itm);\n          }\n        }\n      } else {\n        // item is an index\n        if (!isNaN(item)) {\n          if (this.items.indexOf(this.items[item]) >= 0) {\n            found = this.items[item];\n          }\n        }\n        // item is a node\n        else if (item instanceof Element) {\n          found = this.items[this.nodes.indexOf(item)];\n        }\n        // item is an item\n        else if (isObject(item) && this.items.indexOf(item) >= 0) {\n          found = item;\n        }\n      }\n      return found;\n    },\n    /**\r\n     * Get all items\r\n     * @return {Array}\r\n     */\n    getItems: function () {\n      return this.items;\n    },\n    /**\r\n     * Get all nodes\r\n     * @return {Array}\r\n     */\n    getNodes: function () {\n      return this.nodes;\n    },\n    /**\r\n     * Get the first selected item\r\n     * @return {Object}\r\n     */\n    getFirstSelectedItem() {\n      return this.getSelectedItems()[0];\n    },\n    /**\r\n     * Get the first selected element node\r\n     * @return {HTMLElement}\r\n     */\n    getFirstSelectedNode() {\n      return this.getSelectedNodes()[0];\n    },\n    /**\r\n     * Get all selected items\r\n     * @return {Array}\r\n     */\n    getSelectedItems: function (invert) {\n      return this.getItems().filter(function (item) {\n        return invert ? !item.selected : item.selected;\n      });\n    },\n    /**\r\n     * Get all unselected items\r\n     * @return {Array}\r\n     */\n    getUnSelectedItems: function (invert) {\n      return this.getItems().filter(function (item) {\n        return !item.selected;\n      });\n    },\n    /**\r\n     * Get all selected element nodes\r\n     * @return {Array}\r\n     */\n    getSelectedNodes: function () {\n      return this.getSelectedItems().map(function (item) {\n        return item.node;\n      });\n    },\n    /**\r\n     * Get all unselected element nodes\r\n     * @return {Array}\r\n     */\n    getUnSelectedNodes: function () {\n      return this.getUnSelectedItems().map(function (item) {\n        return item.node;\n      });\n    },\n    /**\r\n     * State method\r\n     * @param  {String} type\r\n     * @return {Void}\r\n     */\n    state: function (type) {\n      var changed = false;\n      var emit = false;\n      switch (type) {\n        case 'save':\n          this.states = this.states || [];\n          this.states.push(this.getSelectedNodes());\n\n          // check we're at max saves limit\n          if (isNumber(this.config.saveState)) {\n            if (this.states.length > this.config.saveState) {\n              this.states.shift();\n            }\n          }\n\n          // move the current state index to the last element\n          this.currentState = this.states.length - 1;\n          emit = true;\n          break;\n        case 'undo':\n          // decrement the current save state\n          if (this.currentState > 0) {\n            this.currentState--;\n            changed = true;\n            emit = true;\n          }\n          break;\n        case 'redo':\n          // increment the current save state\n          if (this.currentState < this.states.length - 1) {\n            this.currentState++;\n            changed = true;\n            emit = true;\n          }\n          break;\n        case 'clear':\n          this.states = [];\n          this.currentState = false;\n          break;\n      }\n\n      // check if the state changed\n      if (changed) {\n        // clear the current selection\n        this.clear(false);\n\n        // select the items in the saved state\n        this.select(this.states[this.currentState], false, false);\n      }\n\n      // check if we need to emit the event\n      if (emit) {\n        this.emit('state.' + type, this.states[this.currentState], this.states);\n      }\n    },\n    /**\r\n     * Undo selection\r\n     * @return {Void}\r\n     */\n    undo: function () {\n      this.state('undo');\n    },\n    /**\r\n     * Redo selection\r\n     * @return {Void}\r\n     */\n    redo: function () {\n      this.state('redo');\n    },\n    /**\r\n     * Enable instance\r\n     * @return {Boolean}\r\n     */\n    enable: function () {\n      if (!this.enabled) {\n        var keys = this.config.keys;\n        this.enabled = true;\n        this.canShift = keys.indexOf('shiftKey') >= 0;\n        this.canCtrl = keys.indexOf('ctrlKey') >= 0;\n        this.canMeta = keys.indexOf('metaKey') >= 0;\n        this.attachEvents();\n        this.container.classList.add(this.config.classes.container);\n        this.emit('enable');\n      }\n      return this.enabled;\n    },\n    /**\r\n     * Disable instance\r\n     * @return {Boolean}\r\n     */\n    disable: function () {\n      if (this.enabled) {\n        var keys = this.config.keys;\n        this.enabled = false;\n        this.detachEvents();\n        this.container.classList.remove(this.config.classes.container);\n        this.emit('disabled');\n      }\n      return this.enabled;\n    },\n    /**\r\n     * Destroy instance\r\n     * @return {void}\r\n     */\n    destroy: function () {\n      if (!this.initialised) return;\n      this.disable();\n      this.emit('destroyed');\n      this.listeners = false;\n      this.clear();\n      this.state('clear');\n      this.remove(this.items);\n      this.callbacks = null;\n      this.initialised = false;\n    },\n    /**\r\n     * Add event handler\r\n     * @param  {String} event\r\n     * @param  {Function} callback\r\n     * @return {Void}\r\n     */\n    on: function (listener, cb, capture) {\n      if (typeof listener === 'string') {\n        this.listeners = this.listeners || {};\n        this.listeners[listener] = this.listeners[listener] || [];\n        this.listeners[listener].push({\n          callback: cb,\n          once: false\n        });\n      } else {\n        arguments[0].addEventListener(arguments[1], arguments[2], false);\n      }\n    },\n    /**\r\n     * Add event handler that will be removed when fired\r\n     * @param  {String} event\r\n     * @param  {Function} callback\r\n     * @return {Void}\r\n     */\n    once: function (listener, cb, capture) {\n      if (typeof listener === 'string') {\n        this.listeners = this.listeners || {};\n        this.listeners[listener] = this.listeners[listener] || [];\n        this.listeners[listener].push({\n          callback: cb,\n          once: true\n        });\n      } else {\n        arguments[0].addEventListener(arguments[1], arguments[2], false);\n      }\n    },\n    /**\r\n     * Remove event handler\r\n     * @param  {String} listener\r\n     * @param  {Function} callback\r\n     * @return {Void}\r\n     */\n    off: function (listener, cb) {\n      if (typeof listener === 'string') {\n        this.listeners = this.listeners || {};\n        if (listener in this.listeners === false) return;\n        for (var i = 0, len = this.listeners[listener].length; i < len; i++) {\n          if (this.listeners[listener][i].callback === cb) {\n            this.listeners[listener].splice(i, 1);\n          }\n        }\n      } else {\n        arguments[0].removeEventListener(arguments[1], arguments[2]);\n      }\n    },\n    /**\r\n     * Fire event\r\n     * @param  {String} listener\r\n     * @return {Void}\r\n     */\n    emit: function (listener) {\n      this.listeners = this.listeners || {};\n\n      // Don't fire the event if it's not being used\n      if (listener in this.listeners === false) return;\n      for (var i = 0, len = this.listeners[listener].length; i < len; i++) {\n        this.listeners[listener][i].callback.apply(this, Array.prototype.slice.call(arguments, 1));\n        if (this.listeners[listener][i].once) {\n          this.off(listener, this.listeners[listener][i].callback);\n        }\n      }\n    },\n    /* ---------- PRIVATE METHODS ---------- */\n\n    _maxReached: function () {\n      return this.emit('maxitems');\n    },\n    /**\r\n     * touchstart event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _touchstart: function (e) {\n      this.off(this.container, 'mousedown', this.callbacks.start);\n      this._start(e);\n    },\n    /**\r\n     * mousedown / touchstart event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _start: function (e) {\n      var that = this,\n        evt = this._getEvent(e),\n        o = this.config,\n        originalEl,\n        cmd = _isCmdKey(e) && (this.canCtrl || this.canMeta),\n        shift = this.canShift && _isShiftKey(e),\n        count = this.getSelectedItems().length,\n        max = o.maxSelectable;\n\n      // max items reached\n      if (!!max && count >= max && (cmd || shift)) {\n        return this._maxReached();\n      }\n      if (!this.container.contains(e.target) || e.which === 3 || e.button > 0 || o.disabled) return;\n\n      // check if the parent container is scrollable and\n      // prevent deselection when clicking on the scrollbars\n      if (this.scroll.scrollable.y && evt.pageX > this.boundingRect.x1 + this.scroll.size.x || this.scroll.scrollable.x && evt.pageY > this.boundingRect.y1 + this.scroll.size.y) {\n        return false;\n      }\n\n      // check for ignored descendants\n      if (this.config.ignore) {\n        var stop = false;\n        var ignore = this.config.ignore;\n        if (!Array.isArray(ignore)) {\n          ignore = [ignore];\n        }\n        for (var i = 0; i < ignore.length; i++) {\n          var ancestor = e.target.closest(ignore[i]);\n          if (ancestor) {\n            stop = true;\n            break;\n          }\n        }\n        if (stop) {\n          return false;\n        }\n      }\n\n      // if handle is set, prevent selection if we start outside the handle element\n      if (this.hasHandle && !e.target.classList.contains(o.classes.handle)) {\n        return false;\n      }\n\n      // selectable nodes may have child elements\n      // so let's get the closest selectable node\n      var node = getClosestAncestor(e.target, function (el) {\n        return el === that.container || el.classList.contains(o.classes.selectable);\n      });\n      if (!node) return false;\n\n      // allow form inputs to be receive focus\n      if (['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA', 'OPTION'].indexOf(e.target.tagName) === -1) {\n        e.preventDefault();\n      }\n      this.dragging = true;\n      this.origin = {\n        x: evt.pageX + (this.bodyContainer ? 0 : this.scroll.x),\n        y: evt.pageY + (this.bodyContainer ? 0 : this.scroll.y),\n        scroll: {\n          x: this.scroll.x,\n          y: this.scroll.y\n        }\n      };\n      if (this.lasso) {\n        this.container.appendChild(this.lasso);\n      }\n      if (node !== this.container) {\n        var item = this.get(node);\n        item.selecting = true;\n        node.classList.add(o.classes.selecting);\n        this.emit('selecting', evt, item);\n      } else {\n        // Fixes #32\n        if (o.lassoSelect == 'sequential') {\n          node = getClosestNodeToPointer(evt, this.items);\n        }\n      }\n      if (o.autoRefresh) {\n        this.refresh();\n      }\n      if (shift && this.startEl && node !== this.container) {\n        var items = this.getItems();\n        var currentIndex = this.getNodes().indexOf(node);\n        var lastIndex = this.getNodes().indexOf(this.getFirstSelectedNode());\n        if (currentIndex > lastIndex) {\n          for (var i = lastIndex + 1; i < currentIndex; i++) {\n            items[i].selecting = true;\n            this.emit('selecting', evt, items[i]);\n          }\n        } else {\n          for (var i = lastIndex - 1; i > currentIndex; i--) {\n            items[i].selecting = true;\n            this.emit('selecting', evt, items[i]);\n          }\n        }\n      }\n      for (var i = 0; i < this.items.length; i++) {\n        var item = this.items[i],\n          el = item.node,\n          isCurrentNode = el === node;\n        if (item.selected) {\n          item.startselected = true;\n          var deselect = o.toggle || cmd ? isCurrentNode : !isCurrentNode && !shift;\n          if (deselect) {\n            el.classList.remove(o.classes.selected);\n            item.selected = false;\n            el.classList.add(o.classes.deselecting);\n            item.deselecting = true;\n            this.emit('deselecting', evt, item);\n          }\n        }\n        if (isCurrentNode) {\n          originalEl = item;\n        }\n      }\n      this.startEl = node;\n      this.emit('start', e, originalEl);\n    },\n    /**\r\n     * mousmove / touchmove event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _drag: function (e) {\n      var o = this.config;\n      if (o.disabled || !this.dragging || !this.canShift) return;\n      var tmp;\n      var evt = this._getEvent(e);\n      var cmd = _isCmdKey(e) && (this.canCtrl || this.canMeta);\n      this.mouse = {\n        x: evt.pageX,\n        y: evt.pageY\n      };\n      this.current = {\n        x1: this.origin.x,\n        y1: this.origin.y,\n        x2: this.mouse.x + (this.bodyContainer ? 0 : this.scroll.x),\n        y2: this.mouse.y + (this.bodyContainer ? 0 : this.scroll.y)\n      };\n\n      // flip lasso\n      for (var i = 0; i < _axes.length; i++) {\n        var axis = _axes[i];\n        if (this.current[_axes1[axis]] > this.current[_axes2[axis]]) {\n          tmp = this.current[_axes2[axis]];\n          this.current[_axes2[axis]] = this.current[_axes1[axis]];\n          this.current[_axes1[axis]] = tmp;\n        }\n      }\n\n      // lasso coordinates\n      this.coords = {\n        x1: this.current.x1,\n        x2: this.current.x2 - this.current.x1,\n        y1: this.current.y1,\n        y2: this.current.y2 - this.current.y1\n      };\n      if (o.lassoSelect === 'normal') {\n        /* highlight */\n        for (var i = 0; i < this.items.length; i++) {\n          this._highlight(this.items[i], _isCmdKey(e) && (this.canCtrl || this.canMeta), evt);\n        }\n      } else if (o.lassoSelect === 'sequential') {\n        this._sequentialSelect(evt);\n      }\n\n      // auto scroll\n      if (this.autoscroll) {\n        // subtract the parent container's position\n        if (!this.bodyContainer) {\n          this.coords.x1 -= this.boundingRect.x1;\n          this.coords.y1 -= this.boundingRect.y1;\n        }\n        this._autoScroll();\n      }\n\n      // lasso\n      if (this.lasso) {\n        // stop lasso causing overflow\n        if (!this.bodyContainer && this.autoscroll && !this.config.autoScroll.lassoOverflow) {\n          this._limitLasso();\n        }\n\n        // style the lasso\n        _css(this.lasso, {\n          left: this.coords.x1,\n          top: this.coords.y1,\n          width: this.coords.x2,\n          height: this.coords.y2,\n          opacity: 1\n        });\n      }\n\n      // emit the \"drag\" event\n      this.emit('drag', e, this.coords);\n    },\n    /**\r\n     * mouseup / touchend event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _end: function (e) {\n      if (!this.dragging) return;\n      this.dragging = false;\n      var that = this,\n        o = that.config,\n        node = e.target,\n        evt = this._getEvent(e),\n        endEl,\n        selected = [],\n        deselected = [],\n        count = this.getSelectedItems().length,\n        max = o.maxSelectable;\n\n      // remove the lasso\n      if (this.lasso && this.container.contains(this.lasso)) {\n        this.container.removeChild(this.lasso);\n      }\n      if (this.lasso) {\n        // Reset the lasso\n        _css(this.lasso, {\n          opacity: 0,\n          left: 0,\n          width: 0,\n          top: 0,\n          height: 0\n        });\n\n        // the lasso was the event.target so let's get the actual\n        // node below the pointer\n        node = document.elementFromPoint(evt.pageX, evt.pageY);\n        if (!node) {\n          node = this.container;\n        }\n      }\n\n      // now let's get the closest valid selectable node\n      endEl = getClosestAncestor(node, function (el) {\n        return el.classList.contains(o.classes.selectable);\n      });\n      var maxReached = false;\n\n      // loop over items and check their state\n      for (var i = 0; i < this.items.length; i++) {\n        var item = this.items[i];\n\n        // If we've mousedown'd and mouseup'd on the same selected item\n        // toggling it's state to deselected won't work if we've dragged even\n        // a small amount. This can happen if we're moving between items quickly\n        // while the mouse button is down. We can fix that here.\n        if (o.toggle && item.node === endEl && item.node === this.startEl) {\n          if (item.selecting && item.startselected) {\n            item.deselecting = true;\n            item.selecting = false;\n            this.emit('deselecting', evt, item);\n          }\n        }\n\n        // item was marked for deselect\n        if (item.deselecting) {\n          deselected.push(item);\n          this.deselect(item, false);\n        }\n\n        // item was marked for select\n        if (item.selecting) {\n          // max items reached\n          if (!!max && count + selected.length >= max) {\n            item.selecting = false;\n            item.node.classList.remove(o.classes.selecting);\n            maxReached = true;\n          } else {\n            selected.push(item);\n            this.select(item, false, false);\n          }\n        }\n      }\n      if (o.saveState) {\n        this.state('save');\n      }\n      this.emit('end', e, selected, deselected);\n      if (maxReached) {\n        return this._maxReached();\n      }\n    },\n    /**\r\n     * keydown event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _keydown: function (e) {\n      this.cmdDown = _isCmdKey(e) && (this.canCtrl || this.canMeta);\n      var code = false;\n      if (e.key !== undefined) {\n        code = e.key;\n      } else if (e.keyCode !== undefined) {\n        code = e.keyCode;\n      }\n      if (code) {\n        if (this.cmdDown && this.focused) {\n          switch (code) {\n            case 65:\n            case 'a':\n            case 'A':\n              e.preventDefault();\n              this.selectAll();\n              break;\n            case 89:\n            case 'y':\n            case 'Y':\n              this.state('redo');\n              break;\n            case 90:\n            case 'z':\n            case 'Z':\n              this.state('undo');\n              break;\n          }\n        } else {\n          switch (code) {\n            case 32:\n            case ' ':\n              this.toggle(document.activeElement);\n              break;\n          }\n        }\n      }\n    },\n    /**\r\n     * keyup event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _keyup: function (e) {\n      this.cmdDown = _isCmdKey(e) && (this.canCtrl || this.canMeta);\n    },\n    /**\r\n     * scroll event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _onScroll: function (e) {\n      this.scroll.x = this.bodyContainer ? window.pageXOffset : this.container.scrollLeft;\n      this.scroll.y = this.bodyContainer ? window.pageYOffset : this.container.scrollTop;\n      for (var i = 0; i < this.items.length; i++) {\n        this.items[i].rect = _getElementBoundingRect(this.items[i].node);\n      }\n    },\n    /**\r\n     * Load items from the given filter\r\n     * @return {void}\r\n     */\n    _loadItems: function () {\n      var o = this.config;\n      this.nodes = [].slice.call(this.container.querySelectorAll('.' + o.classes.selectable));\n      this.items = [];\n      if (this.nodes.length) {\n        for (var i = 0; i < this.nodes.length; i++) {\n          var el = this.nodes[i];\n          el.classList.add(o.classes.selectable);\n          var item = {\n            node: el,\n            rect: _getElementBoundingRect(el),\n            startselected: false,\n            selected: el.classList.contains(o.classes.selected),\n            selecting: el.classList.contains(o.classes.selecting),\n            deselecting: el.classList.contains(o.classes.deselecting)\n          };\n          var isTransformed = this._get2DTransformation(el);\n          if (isTransformed) {\n            var offset = _getElementOffset(el);\n            var trans = isTransformed.translate,\n              origin = isTransformed.origin,\n              scale = isTransformed.scale,\n              w = el.offsetWidth,\n              h = el.offsetHeight,\n              x = offset.left,\n              y = offset.top;\n            var orx = origin.x,\n              ory = origin.y;\n            var hx = w / 2,\n              hy = h / 2;\n            var cx = x + (hx - orx) * scale + orx,\n              cy = y + (hy - ory) * scale + ory;\n            var shx = hx * scale,\n              shy = hy * scale;\n\n            // rect coords\n            var p = [{\n              x: cx - shx,\n              y: cy - shy\n            }, {\n              x: cx + shx,\n              y: cy - shy\n            }, {\n              x: cx + shx,\n              y: cy + shy\n            }, {\n              x: cx - shx,\n              y: cy + shy\n            }];\n\n            // rotate coords\n            for (var n = 0; n <= 3; n++) {\n              p[n] = _rotatePoint(p[n].x + trans.x, p[n].y + trans.y, x + orx + trans.x, y + ory + trans.y, isTransformed.angle);\n            }\n            item.transform = {\n              rect: p\n            };\n          }\n          this.items.push(item);\n        }\n      }\n    },\n    /**\r\n     * Get event\r\n     * @return {Object}\r\n     */\n    _getEvent: function (e) {\n      if (this.touch) {\n        if (e.type === 'touchend') {\n          return e.changedTouches[0];\n        }\n        return e.touches[0];\n      }\n      return e;\n    },\n    /**\r\n     * Scroll container\r\n     * @return {Void}\r\n     */\n    _autoScroll: function () {\n      var as = this.config.autoScroll;\n      var i = as.increment;\n      var t = as.threshold;\n      var inc = {\n        x: 0,\n        y: 0\n      };\n      if (this.bodyContainer) {\n        this.mouse.x -= this.scroll.x;\n        this.mouse.y -= this.scroll.y;\n      }\n\n      // check if we need to scroll\n      for (var n = 0; n < _axes.length; n++) {\n        var axis = _axes[n];\n        if (this.mouse[axis] >= this.boundingRect[_axes2[axis]] - t && this.scroll[axis] < this.scroll.max[axis]) {\n          inc[axis] = i;\n        } else if (this.mouse[axis] <= this.boundingRect[_axes1[axis]] + t && this.scroll[axis] > 0) {\n          inc[axis] = -i;\n        }\n      }\n\n      // scroll the container\n      if (this.bodyContainer) {\n        window.scrollBy(inc.x, inc.y);\n      } else {\n        this.container.scrollTop += inc.y;\n        this.container.scrollLeft += inc.x;\n      }\n    },\n    /**\r\n     * Limit lasso to container boundaries\r\n     * @return {Void}\r\n     */\n    _limitLasso: function () {\n      for (var i = 0; i < _axes.length; i++) {\n        var axis = _axes[i];\n        var max = this.boundingRect[_axes1[axis]] + this.scroll.size[axis];\n        if (this.mouse[axis] >= max && this.scroll[axis] >= this.scroll.max[axis]) {\n          var off = this.origin[axis] - this.boundingRect[_axes1[axis]] - this.scroll[axis];\n          this.coords[_axes1[axis]] = this.origin[axis] - this.boundingRect[_axes1[axis]];\n          this.coords[_axes2[axis]] = max - off - this.boundingRect[_axes1[axis]];\n        }\n        if (this.mouse[axis] <= this.boundingRect[_axes1[axis]] && this.scroll[axis] <= 0) {\n          this.coords[_axes1[axis]] = 0;\n          this.coords[_axes2[axis]] = this.origin[axis] - this.boundingRect[_axes1[axis]];\n        }\n      }\n    },\n    _sequentialSelect: function (e) {\n      var c = this.config.classes,\n        lastEl = document.elementFromPoint(e.pageX, e.pageY - window.pageYOffset),\n        start,\n        end,\n        items;\n      if (lastEl) {\n        lastEl = lastEl.closest('.' + c.selectable);\n        if (lastEl) {\n          if (this.mouse.y > this.origin.y) {\n            start = this.nodes.indexOf(this.startEl);\n            end = this.nodes.indexOf(lastEl);\n          } else if (this.mouse.y < this.origin.y) {\n            start = this.nodes.indexOf(lastEl);\n            end = this.nodes.indexOf(this.startEl);\n          }\n          for (var i = 0; i < this.items.length; i++) {\n            var item = this.items[i];\n            if (i >= start && i <= end) {\n              this._highlight(item, _isCmdKey(e) && (this.canCtrl || this.canMeta));\n            } else {\n              item.selecting = false;\n              item.node.classList.remove(c.selecting);\n            }\n          }\n        }\n      }\n    },\n    /**\r\n     * Highlight an item for selection based on lasso position\r\n     * @param  {Object} item\r\n     * @return {Void}\r\n     */\n    _highlight: function (item, cmd, evt) {\n      var o = this.config,\n        el = item.node,\n        over = false;\n      var x = this.bodyContainer ? 0 : this.scroll.x;\n      var y = this.bodyContainer ? 0 : this.scroll.y;\n      if (o.lassoSelect === 'normal') {\n        if (o.tolerance === 'touch') {\n          // element is 2d transformed so we need to do some more complex collision detection\n          if (item.transform) {\n            var a = [{\n              x: this.origin.x,\n              y: this.origin.y\n            }, {\n              x: this.mouse.x + x,\n              y: this.origin.y\n            }, {\n              x: this.mouse.x + x,\n              y: this.mouse.y + y\n            }, {\n              x: this.origin.x,\n              y: this.mouse.y + y\n            }];\n            over = _areRectsIntersecting(a, item.transform.rect);\n          } else {\n            // element has no 2d transform applied so just detect collision with the bounding box\n            over = !(item.rect.x1 + x > this.current.x2 || item.rect.x2 + x < this.current.x1 || item.rect.y1 + y > this.current.y2 || item.rect.y2 + y < this.current.y1);\n          }\n        } else if (o.tolerance === 'fit') {\n          // this relies on detecting the bounding box of the element so\n          // both normal and 2d transformed elements will work\n          over = item.rect.x1 + x > this.current.x1 && item.rect.x2 + x < this.current.x2 && item.rect.y1 + y > this.current.y1 && item.rect.y2 + y < this.current.y2;\n        }\n      } else {\n        over = true;\n      }\n      if (over) {\n        if (item.selected && !o.toggle) {\n          el.classList.remove(o.classes.selected);\n          item.selected = false;\n        }\n        if (item.deselecting && (!o.toggle || o.toggle && o.toggle !== 'drag')) {\n          el.classList.remove(o.classes.deselecting);\n          item.deselecting = false;\n        }\n        if (!item.selecting) {\n          el.classList.add(o.classes.selecting);\n          item.selecting = true;\n          this.emit('selecting', evt, item);\n        }\n      } else {\n        if (item.selecting) {\n          el.classList.remove(o.classes.selecting);\n          item.selecting = false;\n          if (cmd && item.startselected) {\n            el.classList.add(o.classes.selected);\n            item.selected = true;\n          } else {\n            if (item.startselected && !o.toggle) {\n              el.classList.add(o.classes.deselecting);\n              item.deselecting = true;\n              this.emit('deselecting', evt, item);\n            }\n          }\n        }\n        if (item.selected) {\n          if (!cmd) {\n            if (!item.startselected) {\n              el.classList.remove(o.classes.selected);\n              item.selected = false;\n              el.classList.add(o.classes.deselecting);\n              item.deselecting = true;\n              this.emit('deselecting', evt, item);\n            }\n          }\n        }\n      }\n    },\n    /**\r\n     * mouseenter event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _focus: function (e) {\n      this.focused = true;\n      this.container.classList.add('ui-focused');\n    },\n    /**\r\n     * mouseleave event listener\r\n     * @param  {Object} e Event interface\r\n     * @return {Void}\r\n     */\n    _blur: function (e) {\n      this.focused = false;\n      this.container.classList.remove('ui-focused');\n    },\n    /**\r\n     * Get an element's 2d transformation properties\r\n     * @param  {Object} el HTMLElement\r\n     * @return {Bool|Object}\r\n     */\n    _get2DTransformation: function (el) {\n      var r = window.getComputedStyle(el, null),\n        trans = r.getPropertyValue('-webkit-transform') || r.getPropertyValue('-moz-transform') || r.getPropertyValue('-ms-transform') || r.getPropertyValue('-o-transform') || r.getPropertyValue('transform') || !1;\n      if (trans && 'none' !== trans) {\n        var e = trans.split('(')[1].split(')')[0].split(', '),\n          a = parseFloat(e[0]),\n          n = parseFloat(e[1]),\n          l = Math.sqrt(a * a + n * n),\n          o = r.transformOrigin.split(' ').map(function (o) {\n            return parseFloat(o);\n          });\n        return {\n          angle: Math.round(Math.atan2(n, a) * (180 / Math.PI)),\n          scale: l,\n          origin: {\n            x: parseFloat(o[0]),\n            y: parseFloat(o[1])\n          },\n          translate: {\n            x: parseFloat(e[4]),\n            y: parseFloat(e[5])\n          }\n        };\n      }\n      return !1;\n    }\n  };\n\n  /* ---------- HELPER FUNCTIONS ---------- */\n\n  /**\r\n   * Get node closest to mouse pointer / touch position\r\n   * @param {Object} ev\r\n   * @param {Array} items\r\n   */\n  function getClosestNodeToPointer(ev, items) {\n    var lens = [];\n    for (var i = 0, count = items.length; i < count; i++) {\n      var item = items[i];\n      var len = Math.hypot(item.rect.x1 - parseInt(ev.clientX), item.rect.y1 - parseInt(ev.clientY));\n      lens.push(parseInt(len));\n    }\n    var index = lens.indexOf(Math.min.apply(Math, lens));\n    return items[index].node;\n  }\n\n  /**\r\n   * Find the closest matching ancestor to a node\r\n   * @param  {Object}   el HTMLElement\r\n   * @param  {Function} fn Callback\r\n   * @return {Object|Boolean}\r\n   */\n  function getClosestAncestor(el, fn) {\n    return el && el !== document.documentElement && (fn(el) ? el : getClosestAncestor(el.parentNode, fn));\n  }\n\n  /**\r\n   * Check is item is object\r\n   * @return {Boolean}\r\n   */\n  function isObject(val) {\n    return Object.prototype.toString.call(val) === '[object Object]';\n  }\n\n  /**\r\n   * Check item is iterable\r\n   * @param  {Mixed} arr\r\n   * @return {Boolean}\r\n   */\n  function isCollection(arr) {\n    return Array.isArray(arr) || arr instanceof HTMLCollection || arr instanceof NodeList;\n  }\n\n  /**\r\n   * Check var is a number\r\n   * @param  {Mixed} n\r\n   * @return {Boolean}\r\n   */\n  function isNumber(n) {\n    if ('isInteger' in Number) {\n      return Number.isInteger(n);\n    }\n    return !isNaN(n);\n  }\n\n  /**\r\n   * Merge objects (reccursive)\r\n   * @param  {Object} r\r\n   * @param  {Object} t\r\n   * @return {Object}\r\n   */\n  function _merge(src, props) {\n    for (var prop in props) {\n      if (props.hasOwnProperty(prop)) {\n        var val = props[prop];\n        if (val && isObject(val)) {\n          src[prop] = src[prop] || {};\n          _merge(src[prop], val);\n        } else {\n          src[prop] = val;\n        }\n      }\n    }\n    return src;\n  }\n\n  /**\r\n   * Mass assign style properties\r\n   * @param  {Object} i\r\n   * @param  {(String|Object)} t\r\n   * @param  {String|Object}\r\n   */\n  function _css(i, t) {\n    var e = i.style;\n    if (i) {\n      if (void 0 === t) return window.getComputedStyle(i);\n      if (isObject(t)) for (var n in t) n in e || (n = '-webkit-' + n), i.style[n] = t[n] + ('string' == typeof t[n] ? '' : 'opacity' === n ? '' : 'px');\n    }\n  }\n\n  /**\r\n   * Get an element's DOMRect relative to the document instead of the viewport.\r\n   * @param  {Object} t   HTMLElement\r\n   * @param  {Boolean} e  Include margins\r\n   * @return {Object}     Formatted DOMRect copy\r\n   */\n  function _getElementBoundingRect(e) {\n    var w = window,\n      o = e.getBoundingClientRect(),\n      b = document.documentElement || document.body.parentNode || document.body,\n      d = void 0 !== w.pageXOffset ? w.pageXOffset : b.scrollLeft,\n      n = void 0 !== w.pageYOffset ? w.pageYOffset : b.scrollTop;\n    return {\n      x1: o.left + d,\n      x2: o.left + o.width + d,\n      y1: o.top + n,\n      y2: o.top + o.height + n,\n      height: o.height,\n      width: o.width\n    };\n  }\n\n  /**\r\n   * Returns a function, that, as long as it continues to be invoked, will not be triggered.\r\n   * @param  {Function} fn\r\n   * @param  {Number} lim\r\n   * @param  {Boolean} now\r\n   * @return {Function}\r\n   */\n  function _throttle(fn, lim, context) {\n    var wait;\n    return function () {\n      context = context || this;\n      if (!wait) {\n        fn.apply(context, arguments);\n        wait = true;\n        return setTimeout(function () {\n          wait = false;\n        }, lim);\n      }\n    };\n  }\n  function _getElementOffset(el) {\n    var top = 0,\n      left = 0;\n    do {\n      top += el.offsetTop || 0;\n      left += el.offsetLeft || 0;\n      el = el.offsetParent;\n    } while (el);\n    return {\n      top: top,\n      left: left\n    };\n  }\n  function _rotatePoint(px, py, x, y, theta) {\n    theta = theta * Math.PI / 180.0;\n    return {\n      x: Math.cos(theta) * (px - x) - Math.sin(theta) * (py - y) + x,\n      y: Math.sin(theta) * (px - x) + Math.cos(theta) * (py - y) + y\n    };\n  }\n\n  /**\r\n   * Determine whether there is an intersection between the two rects described\r\n   * by the lists of vertices. Uses the Separating Axis Theorem.\r\n   *\r\n   * @param {Array} a Array of coords\r\n   * @param {Array} b Array of coords\r\n   * @return {Bool}\r\n   */\n  function _areRectsIntersecting(a, b) {\n    var r,\n      o,\n      t,\n      e,\n      n,\n      v,\n      i,\n      d,\n      f = [a, b];\n    for (e = 0; e < f.length; e++) {\n      var g = f[e];\n      for (n = 0; n < g.length; n++) {\n        var h = (n + 1) % g.length,\n          l = g[n],\n          x = g[h],\n          y = x.y - l.y,\n          c = l.x - x.x;\n        for (r = o = void 0, v = 0; v < a.length; v++) t = y * a[v].x + c * a[v].y, (void 0 === r || t < r) && (r = t), (void 0 === o || o < t) && (o = t);\n        for (i = d = void 0, v = 0; v < b.length; v++) t = y * b[v].x + c * b[v].y, (void 0 === i || t < i) && (i = t), (void 0 === d || d < t) && (d = t);\n        if (o < i || d < r) return !1;\n      }\n    }\n    return !0;\n  }\n  return Selectable;\n});\n\n//# sourceURL=webpack://@cjmia/dashboard/../../shared/library/selectable.js?");

/***/ })

}]);